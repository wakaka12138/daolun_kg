<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Prism::ParseResult::Comments - Documentation for Ruby 3.3</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/navigation.js" defer></script>
<script src="../../js/search.js" defer></script>
<script src="../../js/search_index.js" defer></script>
<script src="../../js/searcher.js" defer></script>
<script src="../../js/darkfish.js" defer></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search (/) for a class, method, ..." spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    
<div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  <p class="link"><a href="../../Object.html">Object</a>
</div>

    
    
    
<!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    <li ><a href="#method-c-new">::new</a>
    <li ><a href="#method-i-attach-21">#attach!</a>
    <li ><a href="#method-i-nearest_targets">#nearest_targets</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Prism::ParseResult::Comments">
  <h1 id="class-Prism::ParseResult::Comments" class="class">
    class Prism::ParseResult::Comments
  </h1>

  <section class="description">
    
<p>When we’ve parsed the source, we have both the syntax tree and the list of comments that we found in the source. This class is responsible for walking the tree and finding the nearest location to attach each comment.</p>

<p>It does this by first finding the nearest locations to each comment. Locations can either come from nodes directly or from location fields on nodes. For example, a ‘ClassNode` has an overall location encompassing the entire class, but it also has a location for the `class` keyword.</p>

<p>Once the nearest locations are found, it determines which one to attach to. If it’s a trailing comment (a comment on the same line as other source code), it will favor attaching to the nearest location that occurs before the comment. Otherwise it will favor attaching to the nearest location that is after the comment.</p>

  </section>

  <section id="5Buntitled-5D" class="documentation-section">



    <section class="attribute-method-details" class="method-section">
      <header>
        <h3>Attributes</h3>
      </header>

      <div id="attribute-i-parse_result" class="method-detail">
        <div class="method-heading attribute-method-heading">
          <span class="method-name">parse_result</span><span
            class="attribute-access-type">[R]</span>
        </div>

        <div class="method-description">
        <p>The parse result that we are attaching comments to.</p>
        </div>
      </div>
    </section>


     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-new" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">new</span><span
              class="method-args">(parse_result)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Create a new <a href="Comments.html"><code>Comments</code></a> object that will attach comments to the given parse result.</p>

          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/prism/parse_result/comments.rb, line 78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">parse_result</span>)
  <span class="ruby-ivar">@parse_result</span> = <span class="ruby-identifier">parse_result</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-attach-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">attach!</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Attach the comments to their respective locations in the tree by mutating the parse result.</p>

          <div class="method-source-code" id="attach-21-source">
            <pre><span class="ruby-comment"># File lib/prism/parse_result/comments.rb, line 84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">attach!</span>
  <span class="ruby-identifier">parse_result</span>.<span class="ruby-identifier">comments</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">comment</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">preceding</span>, <span class="ruby-identifier">enclosing</span>, <span class="ruby-identifier">following</span> = <span class="ruby-identifier">nearest_targets</span>(<span class="ruby-identifier">parse_result</span>.<span class="ruby-identifier">value</span>, <span class="ruby-identifier">comment</span>)
    <span class="ruby-identifier">target</span> =
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">comment</span>.<span class="ruby-identifier">trailing?</span>
        <span class="ruby-identifier">preceding</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">following</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">enclosing</span> <span class="ruby-operator">||</span> <span class="ruby-constant">NodeTarget</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parse_result</span>.<span class="ruby-identifier">value</span>)
      <span class="ruby-keyword">else</span>
        <span class="ruby-comment"># If a comment exists on its own line, prefer a leading comment.</span>
        <span class="ruby-identifier">following</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">preceding</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">enclosing</span> <span class="ruby-operator">||</span> <span class="ruby-constant">NodeTarget</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">parse_result</span>.<span class="ruby-identifier">value</span>)
      <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">target</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">comment</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

     <section id="private-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Private Instance Methods</h3>
       </header>

      <div id="method-i-nearest_targets" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">nearest_targets</span><span
              class="method-args">(node, comment)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Responsible for finding the nearest targets to the given comment within the context of the given encapsulating node.</p>

          <div class="method-source-code" id="nearest_targets-source">
            <pre><span class="ruby-comment"># File lib/prism/parse_result/comments.rb, line 103</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">nearest_targets</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">comment</span>)
  <span class="ruby-identifier">comment_start</span> = <span class="ruby-identifier">comment</span>.<span class="ruby-identifier">location</span>.<span class="ruby-identifier">start_offset</span>
  <span class="ruby-identifier">comment_end</span> = <span class="ruby-identifier">comment</span>.<span class="ruby-identifier">location</span>.<span class="ruby-identifier">end_offset</span>

  <span class="ruby-identifier">targets</span> = []
  <span class="ruby-identifier">node</span>.<span class="ruby-identifier">comment_targets</span>.<span class="ruby-identifier">map</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">value</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">StatementsNode</span>
      <span class="ruby-identifier">targets</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">value</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">node</span><span class="ruby-operator">|</span> <span class="ruby-constant">NodeTarget</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">node</span>) })
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Node</span>
      <span class="ruby-identifier">targets</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">NodeTarget</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">value</span>)
    <span class="ruby-keyword">when</span> <span class="ruby-constant">Location</span>
      <span class="ruby-identifier">targets</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">LocationTarget</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">value</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">targets</span>.<span class="ruby-identifier">sort_by!</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:start_offset</span>)
  <span class="ruby-identifier">preceding</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">following</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-identifier">left</span> = <span class="ruby-value">0</span>
  <span class="ruby-identifier">right</span> = <span class="ruby-identifier">targets</span>.<span class="ruby-identifier">length</span>

  <span class="ruby-comment"># This is a custom binary search that finds the nearest nodes to the</span>
  <span class="ruby-comment"># given comment. When it finds a node that completely encapsulates the</span>
  <span class="ruby-comment"># comment, it recurses downward into the tree.</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">left</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">right</span>
    <span class="ruby-identifier">middle</span> = (<span class="ruby-identifier">left</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">right</span>) <span class="ruby-operator">/</span> <span class="ruby-value">2</span>
    <span class="ruby-identifier">target</span> = <span class="ruby-identifier">targets</span>[<span class="ruby-identifier">middle</span>]

    <span class="ruby-identifier">target_start</span> = <span class="ruby-identifier">target</span>.<span class="ruby-identifier">start_offset</span>
    <span class="ruby-identifier">target_end</span> = <span class="ruby-identifier">target</span>.<span class="ruby-identifier">end_offset</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">target</span>.<span class="ruby-identifier">encloses?</span>(<span class="ruby-identifier">comment</span>)
      <span class="ruby-comment"># The comment is completely contained by this target. Abandon the</span>
      <span class="ruby-comment"># binary search at this level.</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">nearest_targets</span>(<span class="ruby-identifier">target</span>.<span class="ruby-identifier">node</span>, <span class="ruby-identifier">comment</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">target_end</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">comment_start</span>
      <span class="ruby-comment"># This target falls completely before the comment. Because we will</span>
      <span class="ruby-comment"># never consider this target or any targets before it again, this</span>
      <span class="ruby-comment"># target must be the closest preceding target we have encountered so</span>
      <span class="ruby-comment"># far.</span>
      <span class="ruby-identifier">preceding</span> = <span class="ruby-identifier">target</span>
      <span class="ruby-identifier">left</span> = <span class="ruby-identifier">middle</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">comment_end</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">target_start</span>
      <span class="ruby-comment"># This target falls completely after the comment. Because we will</span>
      <span class="ruby-comment"># never consider this target or any targets after it again, this</span>
      <span class="ruby-comment"># target must be the closest following target we have encountered so</span>
      <span class="ruby-comment"># far.</span>
      <span class="ruby-identifier">following</span> = <span class="ruby-identifier">target</span>
      <span class="ruby-identifier">right</span> = <span class="ruby-identifier">middle</span>
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># This should only happen if there is a bug in this parser.</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-string">&quot;Comment location overlaps with a target location&quot;</span>
  <span class="ruby-keyword">end</span>

  [<span class="ruby-identifier">preceding</span>, <span class="ruby-constant">NodeTarget</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">node</span>), <span class="ruby-identifier">following</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.6.3.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

